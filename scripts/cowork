#!/bin/bash
#
# cowork - CLI wrapper for Cowork Sandbox
# Simplifies interaction with Claude Code running in Lima VM
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# Change to home directory to avoid Lima's "cd: No such file or directory" warning
# Lima tries to cd to host's current directory which may not exist in VM
cd ~

VM_NAME="${COWORK_VM_NAME:-sandbox}"
WORKSPACE="${COWORK_WORKSPACE:-/workspace}"

# Runtime configuration (can be overridden via command line)
PROXY_HOST="${COWORK_PROXY_HOST:-}"
PROXY_PORT="${COWORK_PROXY_PORT:-7890}"
CUSTOM_MOUNT="${COWORK_MOUNT:-}"

# PATH prefix for commands executed in VM (needed for non-login shells)
VM_PATH_PREFIX='export PATH="$HOME/.npm-global/bin:$HOME/.local/bin:$PATH" &&'

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_header() {
    echo -e "${BLUE}╭─────────────────────────────────────╮${NC}"
    echo -e "${BLUE}│      Cowork Sandbox Controller      │${NC}"
    echo -e "${BLUE}╰─────────────────────────────────────╯${NC}"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1" >&2
}

print_info() {
    echo -e "${YELLOW}→${NC} $1"
}

# Check if Lima is installed
check_lima() {
    if ! command -v limactl &> /dev/null; then
        print_error "Lima is not installed. Install with: brew install lima"
        exit 1
    fi
}

# Check VM status
vm_status() {
    # Lima 2.x outputs a single JSON object, not an array
    # Try new format first, then fall back to old format for compatibility
    local status
    status=$(limactl list --json 2>/dev/null | jq -r "if type == \"array\" then .[] | select(.name == \"$VM_NAME\") | .status else if .name == \"$VM_NAME\" then .status else empty end end" 2>/dev/null)
    if [ -z "$status" ]; then
        echo "NotFound"
    else
        echo "$status"
    fi
}

# Execute command in VM with cd warning suppression
# Usage: vm_exec command args (without --)
vm_exec() {
    (limactl shell "$VM_NAME" -- "$@") 2>&1 | { grep -v "cd:.*No such file or directory" || true; }
}

# Execute bash command in VM with cd warning suppression
# Usage: vm_bash "command string"
vm_bash() {
    (limactl shell "$VM_NAME" -- bash -c "cd ~ 2>/dev/null; $1") 2>&1 | { grep -v "cd:.*No such file or directory" || true; }
}

# Generate runtime Lima config with dynamic settings
generate_runtime_config() {
    local config_file="$1"
    local base_config="$PROJECT_DIR/sandbox.yaml"

    # Read base config content
    local config_content
    config_content=$(cat "$base_config")

    # Add custom mount if specified - insert into existing mounts array
    if [ -n "$CUSTOM_MOUNT" ]; then
        local host_path="${CUSTOM_MOUNT%%:*}"
        local vm_path="${CUSTOM_MOUNT##*:}"

        # Expand ~ in host path
        host_path="${host_path/#\~/$HOME}"

        # Ensure host directory exists
        mkdir -p "$host_path"

        # Create mount entry and insert after "mounts:" line using awk
        config_content=$(printf '%s' "$config_content" | awk -v hp="$host_path" -v vp="$vm_path" '
            /^mounts:/ {
                print
                print "  - location: \"" hp "\""
                print "    writable: true"
                print "    mountPoint: \"" vp "\""
                next
            }
            { print }
        ')
        print_info "Added custom mount: $host_path -> $vm_path"
    fi

    # Add proxy configuration if specified - insert into existing env section
    if [ -n "$PROXY_HOST" ]; then
        local proxy_url="http://${PROXY_HOST}:${PROXY_PORT}"

        # Insert after "env:" line using awk
        config_content=$(printf '%s' "$config_content" | awk -v pu="$proxy_url" '
            /^env:/ {
                print
                print "  HTTP_PROXY: \"" pu "\""
                print "  HTTPS_PROXY: \"" pu "\""
                print "  http_proxy: \"" pu "\""
                print "  https_proxy: \"" pu "\""
                print "  NO_PROXY: \"localhost,127.0.0.1\""
                print "  no_proxy: \"localhost,127.0.0.1\""
                next
            }
            { print }
        ')
        print_info "Added proxy configuration: $proxy_url"
    fi

    # Write to config file
    printf '%s\n' "$config_content" > "$config_file"
}

# Initialize/Create VM
cmd_init() {
    check_lima

    print_header
    print_info "Initializing Cowork Sandbox VM..."

    # Check if VM already exists
    local status=$(vm_status)
    if [ "$status" != "NotFound" ]; then
        print_info "VM '$VM_NAME' already exists (status: $status)"
        if [ "$status" != "Running" ]; then
            print_info "Starting VM..."
            limactl start "$VM_NAME"
        fi
    else
        # Create workspace directory on host
        mkdir -p "$HOME/Downloads/cowork-workspace"

        # Generate runtime config with dynamic settings
        local runtime_config
        runtime_config=$(mktemp)
        mv "$runtime_config" "${runtime_config}.yaml"
        runtime_config="${runtime_config}.yaml"
        generate_runtime_config "$runtime_config"

        # Create VM from runtime config
        print_info "Creating VM from sandbox.yaml (with runtime config)..."
        limactl start --name="$VM_NAME" "$runtime_config"

        # Cleanup temp config
        rm -f "$runtime_config"
    fi

    print_success "VM initialized successfully!"

    # Show status
    cmd_status
}

# Start VM
cmd_start() {
    check_lima

    local status=$(vm_status)
    if [ "$status" == "Running" ]; then
        print_info "VM is already running"
    elif [ "$status" == "NotFound" ]; then
        print_error "VM not found. Run 'cowork init' first."
        exit 1
    else
        print_info "Starting VM..."
        limactl start "$VM_NAME"
        print_success "VM started"
    fi
}

# Stop VM
cmd_stop() {
    check_lima

    print_info "Stopping VM..."
    limactl stop "$VM_NAME" 2>/dev/null || true
    print_success "VM stopped"
}

# Show VM status
cmd_status() {
    check_lima

    print_header

    local status=$(vm_status)
    echo ""
    echo "VM Status:"
    echo "  Name:   $VM_NAME"
    echo "  Status: $status"

    if [ "$status" == "Running" ]; then
        echo ""
        echo "Environment:"
        echo "  Python: $(limactl shell "$VM_NAME" -- python3 --version 2>/dev/null | cut -d' ' -f2)"
        echo "  Node:   $(limactl shell "$VM_NAME" -- node --version 2>/dev/null)"
        echo "  Claude: $(limactl shell "$VM_NAME" -- bash -c "$VM_PATH_PREFIX claude --version" 2>/dev/null || echo 'not installed')"
        echo ""
        echo "Workspace: $WORKSPACE"
        echo "  Files: $(limactl shell "$VM_NAME" -- ls "$WORKSPACE" 2>/dev/null | wc -l | tr -d ' ') items"
    fi
    echo ""
}

# Enter VM shell
cmd_shell() {
    check_lima

    local status=$(vm_status)
    if [ "$status" != "Running" ]; then
        print_error "VM is not running. Run 'cowork start' first."
        exit 1
    fi

    local workingdir=""

    # Parse options
    while [ $# -gt 0 ]; do
        case "$1" in
            --workingdir|--wd)
                shift
                workingdir="$1"
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    # Determine workspace path
    local vm_workspace="$WORKSPACE"

    if [ -n "$workingdir" ]; then
        workingdir="${workingdir/#\~/$HOME}"
        if [[ "$workingdir" == "$HOME"* ]]; then
            local relative_path="${workingdir#$HOME}"
            vm_workspace="/tmp/lima${relative_path}"
        else
            print_error "workingdir must be under home directory (~)"
            exit 1
        fi
    fi

    print_info "Entering VM shell (exit with 'exit' or Ctrl+D)..."
    limactl shell --workdir "$vm_workspace" "$VM_NAME"
}

# Run Claude interactively in VM
cmd_claude() {
    check_lima

    local status=$(vm_status)
    if [ "$status" != "Running" ]; then
        print_error "VM is not running. Run 'cowork start' first."
        exit 1
    fi

    local workingdir=""
    local skip_permissions=true

    # Parse cowork-specific flags first
    while [ $# -gt 0 ]; do
        case "$1" in
            --workingdir|--wd)
                shift
                workingdir="$1"
                shift
                ;;
            --no-dangerously-skip-permissions)
                skip_permissions=false
                shift
                ;;
            *)
                # Stop parsing, rest goes to Claude
                break
                ;;
        esac
    done

    # Determine actual workspace path in VM
    local vm_workspace="$WORKSPACE"

    if [ -n "$workingdir" ]; then
        # --workingdir specified: convert host path to VM path
        workingdir="${workingdir/#\~/$HOME}"

        if [[ "$workingdir" == "$HOME"* ]]; then
            local relative_path="${workingdir#$HOME}"
            vm_workspace="/tmp/lima${relative_path}"
        else
            print_error "workingdir must be under home directory (~)"
            exit 1
        fi

        # Create directory if not exists
        vm_exec mkdir -p "$vm_workspace"
    elif ! vm_exec test -d "$WORKSPACE" 2>/dev/null; then
        # Fallback to home-mounted cowork-workspace (via /tmp/lima mount)
        vm_workspace="/tmp/lima/Downloads/cowork-workspace"
    fi


    # Ensure Claude config is linked to host (for existing VMs that don't have the symlink)
    vm_bash "
        if [ -d /tmp/lima/.claude ] && [ ! -L ~/.claude ]; then
            rm -rf ~/.claude 2>/dev/null || true
            ln -sf /tmp/lima/.claude ~/.claude
        fi
    " >/dev/null 2>&1 || true

    # Build environment variables for Claude API
    local env_vars=""
    if [ -n "$ANTHROPIC_API_KEY" ]; then
        env_vars="ANTHROPIC_API_KEY='$ANTHROPIC_API_KEY' "
    fi
    if [ -n "$ANTHROPIC_AUTH_TOKEN" ]; then
        env_vars="${env_vars}ANTHROPIC_AUTH_TOKEN='$ANTHROPIC_AUTH_TOKEN' "
    fi
    if [ -n "$ANTHROPIC_BASE_URL" ]; then
        env_vars="${env_vars}ANTHROPIC_BASE_URL='$ANTHROPIC_BASE_URL' "
    fi

    # Build Claude options
    local claude_opts=""
    if [ "$skip_permissions" = true ]; then
        claude_opts="--dangerously-skip-permissions"
    fi

    # Pass all remaining arguments to Claude CLI (interactive mode)
    # Keep raw output without filtering for interactive use
    limactl shell --workdir "$vm_workspace" "$VM_NAME" -- bash -c "cd ~ 2>/dev/null; $VM_PATH_PREFIX cd $vm_workspace && ${env_vars}claude $claude_opts $(printf '%q ' "$@")"
}

# Ask Claude (supports all Claude CLI arguments)
# Usage: cmd_ask [--project <name>] [claude options] "prompt"
cmd_ask() {
    check_lima

    local project=""
    local workingdir=""
    local skip_permissions=true

    # Parse cowork-specific flags first
    while [ $# -gt 0 ]; do
        case "$1" in
            --project|--proj)
                shift
                project="$1"
                shift
                ;;
            --workingdir|--wd)
                shift
                workingdir="$1"
                shift
                ;;
            --no-dangerously-skip-permissions)
                skip_permissions=false
                shift
                ;;
            *)
                # Stop parsing, rest goes to Claude
                break
                ;;
        esac
    done

    # Everything else goes to Claude
    if [ $# -eq 0 ]; then
        print_error "Usage: cowork ask [options] [claude options] \"prompt\""
        print_error ""
        print_error "Cowork Options:"
        print_error "  --project <name>                   Work in /workspace/<name>"
        print_error "  --workingdir <path>                Work in host path (e.g., ~/Projects/app)"
        print_error "  --no-dangerously-skip-permissions  Don't auto-add --dangerously-skip-permissions"
        print_error ""
        print_error "All Claude Code options are supported (passed through directly):"
        print_error "  -c, --continue        Continue previous conversation"
        print_error "  --plan                Plan mode (no execution)"
        print_error "  --model <model>       Specify model"
        print_error "  --allowedTools <t>    Specify allowed tools"
        print_error "  ... and more (see 'claude --help')"
        print_error ""
        print_error "Examples:"
        print_error "  cowork ask \"write hello world\""
        print_error "  cowork ask --project myapp \"create a flask app\""
        print_error "  cowork ask --workingdir ~/Projects/app \"add tests\""
        print_error "  cowork ask --plan \"design a REST API\""
        print_error "  cowork ask -c \"continue this\""
        exit 1
    fi

    local status=$(vm_status)
    if [ "$status" != "Running" ]; then
        print_info "Starting VM..."
        cmd_start
    fi

    # Determine actual workspace path in VM
    local vm_workspace="$WORKSPACE"

    if [ -n "$workingdir" ]; then
        # --workingdir specified: convert host path to VM path
        # Expand ~ to $HOME
        workingdir="${workingdir/#\~/$HOME}"

        # Convert host path to VM path via /tmp/lima mount
        # /Users/xxx/... -> /tmp/lima/...
        if [[ "$workingdir" == "$HOME"* ]]; then
            # Remove $HOME prefix and prepend /tmp/lima
            local relative_path="${workingdir#$HOME}"
            vm_workspace="/tmp/lima${relative_path}"
        else
            print_error "workingdir must be under home directory (~)"
            exit 1
        fi

        # Create directory if not exists
        vm_exec mkdir -p "$vm_workspace"
    elif [ -n "$project" ]; then
        # --project specified: use /workspace/<project>
        if ! vm_exec test -d "$WORKSPACE" 2>/dev/null; then
            vm_workspace="/tmp/lima/Downloads/cowork-workspace"
        fi
        vm_workspace="$vm_workspace/$project"
        # Create project directory if not exists
        vm_exec mkdir -p "$vm_workspace"
    else
        # Default: use $WORKSPACE
        if ! vm_exec test -d "$WORKSPACE" 2>/dev/null; then
            vm_workspace="/tmp/lima/Downloads/cowork-workspace"
        fi
    fi

    # Ensure Claude config is linked to host (for existing VMs that don't have the symlink)
    vm_bash "
        if [ -d /tmp/lima/.claude ] && [ ! -L ~/.claude ]; then
            rm -rf ~/.claude 2>/dev/null || true
            ln -sf /tmp/lima/.claude ~/.claude
        fi
    " >/dev/null 2>&1 || true

    # Build environment variables for Claude API
    local env_vars=""
    if [ -n "$ANTHROPIC_API_KEY" ]; then
        env_vars="ANTHROPIC_API_KEY='$ANTHROPIC_API_KEY' "
    fi
    if [ -n "$ANTHROPIC_AUTH_TOKEN" ]; then
        env_vars="${env_vars}ANTHROPIC_AUTH_TOKEN='$ANTHROPIC_AUTH_TOKEN' "
    fi
    if [ -n "$ANTHROPIC_BASE_URL" ]; then
        env_vars="${env_vars}ANTHROPIC_BASE_URL='$ANTHROPIC_BASE_URL' "
    fi

    # Build Claude command
    # Default: add -p (print mode) and --dangerously-skip-permissions (sandbox default)
    local claude_opts="-p"
    if [ "$skip_permissions" = true ]; then
        claude_opts="$claude_opts --dangerously-skip-permissions"
    fi

    # Pass all remaining arguments to Claude CLI (supports all Claude options)
    # Use limactl shell directly (not vm_bash) to avoid pipe buffering issues
    limactl shell --workdir "$vm_workspace" "$VM_NAME" -- bash -c "cd ~ 2>/dev/null; $VM_PATH_PREFIX cd $vm_workspace && ${env_vars}claude $claude_opts $(printf '%q ' "$@")"
}

# Execute command in VM
cmd_exec() {
    check_lima

    if [ -z "$1" ]; then
        print_error "Usage: cowork exec \"command\""
        exit 1
    fi

    local status=$(vm_status)
    if [ "$status" != "Running" ]; then
        print_error "VM is not running. Run 'cowork start' first."
        exit 1
    fi

    vm_bash "source ~/.bashrc 2>/dev/null; $*"
}

# Delete VM
cmd_delete() {
    check_lima

    print_info "This will delete the VM and all data inside."
    read -p "Are you sure? (y/N) " -n 1 -r
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        limactl delete "$VM_NAME" -f 2>/dev/null || true
        print_success "VM deleted"
    else
        print_info "Cancelled"
    fi
}

# Export VM as pre-built image
cmd_export() {
    check_lima

    local output_file=""
    local format="tar.gz"

    # Parse options
    while [ $# -gt 0 ]; do
        case "$1" in
            -o|--output)
                shift
                output_file="$1"
                shift
                ;;
            --format)
                shift
                format="$1"
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    # Default output file name
    if [ -z "$output_file" ]; then
        local timestamp=$(date +%Y%m%d_%H%M%S)
        output_file="$HOME/Downloads/cowork-sandbox-${timestamp}.tar.gz"
    fi

    # Ensure output file has correct extension
    if [[ "$output_file" != *.tar.gz ]] && [[ "$output_file" != *.tgz ]]; then
        output_file="${output_file}.tar.gz"
    fi

    local status=$(vm_status)
    if [ "$status" == "NotFound" ]; then
        print_error "VM '$VM_NAME' not found. Nothing to export."
        exit 1
    fi

    print_header
    print_info "Exporting VM '$VM_NAME' as pre-built image..."
    echo ""

    # Stop VM if running (required for clean export)
    local was_running=false
    if [ "$status" == "Running" ]; then
        was_running=true
        print_info "Stopping VM for clean export..."
        limactl stop "$VM_NAME"
        sleep 2
    fi

    local lima_vm_dir="$HOME/.lima/$VM_NAME"

    if [ ! -d "$lima_vm_dir" ]; then
        print_error "VM directory not found: $lima_vm_dir"
        exit 1
    fi

    # Create temporary directory for packaging
    local tmp_dir=$(mktemp -d)
    local vm_export_dir="$tmp_dir/vm"
    mkdir -p "$vm_export_dir"

    print_info "Copying VM files..."

    # Copy essential VM files
    # - basedisk: base disk image (if exists)
    # - diffdisk: differential disk with changes
    # - lima.yaml: VM configuration
    # - cidata.iso: cloud-init data (if exists)

    if [ -f "$lima_vm_dir/basedisk" ]; then
        cp "$lima_vm_dir/basedisk" "$vm_export_dir/"
        print_info "  Copied basedisk"
    fi

    if [ -f "$lima_vm_dir/diffdisk" ]; then
        cp "$lima_vm_dir/diffdisk" "$vm_export_dir/"
        print_info "  Copied diffdisk"
    fi

    if [ -f "$lima_vm_dir/lima.yaml" ]; then
        cp "$lima_vm_dir/lima.yaml" "$vm_export_dir/"
        print_info "  Copied lima.yaml"
    fi

    if [ -f "$lima_vm_dir/cidata.iso" ]; then
        cp "$lima_vm_dir/cidata.iso" "$vm_export_dir/"
        print_info "  Copied cidata.iso"
    fi

    # Copy any other essential files
    for file in "$lima_vm_dir"/*.yaml "$lima_vm_dir"/*.json; do
        if [ -f "$file" ] && [ "$(basename "$file")" != "lima.yaml" ]; then
            cp "$file" "$vm_export_dir/" 2>/dev/null || true
        fi
    done

    # Create metadata file
    cat > "$vm_export_dir/export-metadata.json" << EOF
{
    "exported_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "vm_name": "$VM_NAME",
    "host_arch": "$(uname -m)",
    "host_os": "$(uname -s)",
    "lima_version": "$(limactl --version 2>/dev/null | head -1 || echo 'unknown')"
}
EOF

    print_info "Creating archive..."

    # Create tar.gz archive
    tar -czf "$output_file" -C "$tmp_dir" vm

    # Cleanup
    rm -rf "$tmp_dir"

    # Calculate file size
    local file_size=$(du -h "$output_file" | cut -f1)

    # Restart VM if it was running
    if [ "$was_running" = true ]; then
        print_info "Restarting VM..."
        limactl start "$VM_NAME"
    fi

    echo ""
    print_success "VM exported successfully!"
    echo ""
    echo "  Output: $output_file"
    echo "  Size:   $file_size"
    echo ""
    echo "To import this image on another machine:"
    echo ""
    echo "  # Option 1: Using install.sh"
    echo "  ./install.sh --import $output_file"
    echo ""
    echo "  # Option 2: Using environment variable"
    echo "  COWORK_IMPORT_IMAGE=$output_file ./install.sh"
    echo ""
}

# Configure VM (modify mount/proxy without rebuilding)
cmd_config() {
    check_lima

    local lima_config="$HOME/.lima/$VM_NAME/lima.yaml"
    local show_only=true
    local new_mount=""
    local new_proxy=""
    local remove_proxy=false
    local remove_mount=""

    # Parse options
    while [ $# -gt 0 ]; do
        case "$1" in
            --mount)
                shift
                new_mount="$1"
                show_only=false
                shift
                ;;
            --remove-mount)
                shift
                remove_mount="$1"
                show_only=false
                shift
                ;;
            --proxy)
                shift
                new_proxy="$1"
                show_only=false
                shift
                ;;
            --no-proxy)
                remove_proxy=true
                show_only=false
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    # Check if VM exists
    if [ ! -f "$lima_config" ]; then
        print_error "VM '$VM_NAME' not found. Run 'cowork init' first."
        exit 1
    fi

    # Show current config
    if [ "$show_only" = true ]; then
        print_header
        echo "VM: $VM_NAME"
        echo "Config: $lima_config"
        echo ""
        echo "Mounts:"
        # Extract all mounts using awk - improved version
        awk '
            BEGIN { in_mounts=0; loc=""; writable="false"; mp="" }
            /^mounts:/ { in_mounts=1; next }
            /^[a-zA-Z]/ && !/^[[:space:]]/ && in_mounts {
                # End of mounts section - print last entry
                if (loc != "") {
                    printf "  %s -> ", loc
                    if (mp != "") printf "%s", mp
                    else if (loc == "~") printf "~ (home dir)"
                    else printf "%s", loc
                    if (writable == "true") printf " [rw]"
                    else printf " [ro]"
                    printf "\n"
                    loc = ""
                }
                in_mounts=0
            }
            in_mounts && /^[[:space:]]*- location:/ {
                # Print previous mount if exists
                if (loc != "") {
                    printf "  %s -> ", loc
                    if (mp != "") printf "%s", mp
                    else if (loc == "~") printf "~ (home dir)"
                    else printf "%s", loc
                    if (writable == "true") printf " [rw]"
                    else printf " [ro]"
                    printf "\n"
                }
                # Start new mount entry
                gsub(/.*location: *"?/, ""); gsub(/".*/, "")
                loc = $0; writable = "false"; mp = ""
            }
            in_mounts && /^[[:space:]]*writable:/ {
                gsub(/.*writable: */, ""); gsub(/[[:space:]].*/, "")
                writable = $0
            }
            in_mounts && /^[[:space:]]*mountPoint:/ {
                gsub(/.*mountPoint: *"?/, ""); gsub(/".*/, "")
                mp = $0
            }
            END {
                # Print last mount if still in mounts section (file ends in mounts)
                if (in_mounts && loc != "") {
                    printf "  %s -> ", loc
                    if (mp != "") printf "%s", mp
                    else if (loc == "~") printf "~ (home dir)"
                    else printf "%s", loc
                    if (writable == "true") printf " [rw]"
                    else printf " [ro]"
                    printf "\n"
                }
            }
        ' "$lima_config"
        echo ""
        echo "Proxy:"
        grep -E "^\s*(HTTP_PROXY|http_proxy):" "$lima_config" | head -1 | sed 's/.*: *"*/  /' | sed 's/"*$//' || echo "  (not configured)"
        echo ""
        echo "To modify:"
        echo "  cowork config --mount <host_path>:<vm_path>  # Add mount"
        echo "  cowork config --remove-mount <vm_path>       # Remove mount by VM path"
        echo "  cowork config --proxy <host:port>            # Set proxy"
        echo "  cowork config --no-proxy                     # Remove proxy"
        return
    fi

    # Stop VM before modifying config
    local status=$(vm_status)
    local was_running=false
    if [ "$status" == "Running" ]; then
        was_running=true
        print_info "Stopping VM to apply changes..."
        limactl stop "$VM_NAME" --force
    fi

    # Modify mount using awk
    if [ -n "$new_mount" ]; then
        local host_path="${new_mount%%:*}"
        local vm_path="${new_mount##*:}"
        host_path="${host_path/#\~/$HOME}"

        # Ensure host directory exists
        mkdir -p "$host_path"

        # Create temp file
        local tmp_config=$(mktemp)

        # Add new mount entry after "mounts:" line
        awk -v hp="$host_path" -v vp="$vm_path" '
            /^mounts:/ {
                print
                print "  - location: \"" hp "\""
                print "    writable: true"
                print "    mountPoint: \"" vp "\""
                next
            }
            { print }
        ' "$lima_config" > "$tmp_config"

        mv "$tmp_config" "$lima_config"
        print_info "Added mount: $host_path -> $vm_path"
    fi

    # Remove mount by VM path using awk
    if [ -n "$remove_mount" ]; then
        local tmp_config=$(mktemp)

        # Use awk to remove the mount entry matching the VM path
        # Buffer each mount entry, check mountPoint, then decide to print or skip
        awk -v target="$remove_mount" '
            BEGIN { in_mounts=0; entry=""; has_target=0 }

            /^mounts:/ { in_mounts=1; print; next }

            # End of mounts section
            /^[a-zA-Z]/ && !/^[[:space:]]/ && in_mounts {
                # Flush last entry if not target
                if (entry != "" && !has_target) printf "%s", entry
                in_mounts=0
                entry=""
                has_target=0
                print
                next
            }

            # New mount entry starts
            in_mounts && /^[[:space:]]*- location:/ {
                # Flush previous entry if not target
                if (entry != "" && !has_target) printf "%s", entry
                # Start new entry
                entry = $0 "\n"
                has_target = 0
                next
            }

            # Inside a mount entry
            in_mounts && entry != "" {
                entry = entry $0 "\n"
                # Check if mountPoint matches target
                if (/mountPoint:/) {
                    mp = $0
                    gsub(/.*mountPoint: *"?/, "", mp)
                    gsub(/".*/, "", mp)
                    if (mp == target) has_target = 1
                }
                next
            }

            { print }

            END {
                # Flush last entry if not target
                if (entry != "" && !has_target) printf "%s", entry
            }
        ' "$lima_config" > "$tmp_config"

        mv "$tmp_config" "$lima_config"
        print_info "Removed mount with VM path: $remove_mount"
    fi

    # Modify proxy using awk
    if [ -n "$new_proxy" ]; then
        local proxy_host="${new_proxy%%:*}"
        local proxy_port="${new_proxy##*:}"
        local proxy_url="http://${proxy_host}:${proxy_port}"

        local tmp_config=$(mktemp)

        # First remove old proxy lines
        grep -v -E "^[[:space:]]*(HTTP_PROXY|HTTPS_PROXY|http_proxy|https_proxy|NO_PROXY|no_proxy):" "$lima_config" > "$tmp_config"

        # Add new proxy entries after "env:" line
        awk -v pu="$proxy_url" '
            /^env:/ {
                print
                print "  HTTP_PROXY: \"" pu "\""
                print "  HTTPS_PROXY: \"" pu "\""
                print "  http_proxy: \"" pu "\""
                print "  https_proxy: \"" pu "\""
                print "  NO_PROXY: \"localhost,127.0.0.1\""
                print "  no_proxy: \"localhost,127.0.0.1\""
                next
            }
            { print }
        ' "$tmp_config" > "$lima_config"

        rm -f "$tmp_config"
        print_info "Updated proxy: $proxy_url"
    fi

    # Remove proxy
    if [ "$remove_proxy" = true ]; then
        local tmp_config=$(mktemp)
        grep -v -E "^[[:space:]]*(HTTP_PROXY|HTTPS_PROXY|http_proxy|https_proxy|NO_PROXY|no_proxy):" "$lima_config" > "$tmp_config"
        mv "$tmp_config" "$lima_config"
        print_info "Removed proxy configuration"
    fi

    # Restart VM if it was running
    if [ "$was_running" = true ]; then
        print_info "Starting VM with new configuration..."
        limactl start "$VM_NAME"
        print_success "Configuration applied"
    else
        print_success "Configuration updated. Run 'cowork start' to apply."
    fi
}

# Start proxy monitor
cmd_proxy() {
    check_lima

    local log_file=""
    local verbose=""

    # Parse options
    while [ $# -gt 0 ]; do
        case "$1" in
            -l|--log)
                shift
                log_file="$1"
                shift
                ;;
            -v|--verbose)
                verbose="-v"
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    print_header
    print_info "Starting network proxy monitor on port 7890..."
    print_info "This will log all HTTP/HTTPS traffic from the VM"
    print_info "Press Ctrl+C to stop"
    echo ""

    # Build command
    local cmd="python3 $PROJECT_DIR/host/proxy_monitor.py --host 0.0.0.0 --port 7890"
    if [ -n "$log_file" ]; then
        cmd="$cmd --log-file $log_file"
    fi
    if [ -n "$verbose" ]; then
        cmd="$cmd $verbose"
    fi

    # Run proxy monitor
    $cmd
}

# List all cowork VMs
cmd_list() {
    check_lima

    print_header
    echo ""
    echo "Cowork Sandbox VMs:"
    echo ""

    # Get all VMs and filter/display
    local found=false
    while IFS= read -r line; do
        if [ -n "$line" ]; then
            found=true
            local name=$(echo "$line" | jq -r '.name // "unknown"')
            local status=$(echo "$line" | jq -r '.status // "unknown"')
            local arch=$(echo "$line" | jq -r '.arch // "unknown"')
            local cpus=$(echo "$line" | jq -r '.cpus // 0')
            local memory=$(echo "$line" | jq -r 'if .memory then (.memory / 1024 / 1024 / 1024 | floor) else 0 end')
            local disk=$(echo "$line" | jq -r 'if .disk then (.disk / 1024 / 1024 / 1024 | floor) else 0 end')

            # Status color
            local status_color="$RED"
            if [ "$status" == "Running" ]; then
                status_color="$GREEN"
            elif [ "$status" == "Stopped" ]; then
                status_color="$YELLOW"
            fi

            printf "  %-20s ${status_color}%-10s${NC} %s, %s CPUs, %sG RAM, %sG Disk\n" \
                "$name" "$status" "$arch" "$cpus" "$memory" "$disk"
        fi
    done < <(limactl list --json 2>/dev/null | jq -c 'if type == "array" then .[] else . end')

    if [ "$found" = false ]; then
        echo "  No VMs found"
    fi
    echo ""
}

# ============================================================================
# CUI (Claude UI) Commands
# ============================================================================

CUI_REPO="${COWORK_CUI_REPO:-https://github.com/jingmca/cui.git}"
CUI_DIR="/workspace/cui"
CUI_SERVER_PORT="${COWORK_CUI_PORT:-3001}"
CUI_WEB_PORT="${COWORK_CUI_WEB_PORT:-3000}"

# Deploy CUI to sandbox /workspace
cmd_cui_deploy() {
    check_lima

    local status=$(vm_status)
    if [ "$status" != "Running" ]; then
        print_info "Starting VM..."
        cmd_start
    fi

    print_info "Deploying CUI to $CUI_DIR..."

    # Check if CUI is already deployed (use vm_bash to properly check)
    if vm_bash "test -d $CUI_DIR/.git && echo EXISTS" 2>/dev/null | grep -q "EXISTS"; then
        print_info "CUI already exists, updating..."
        vm_bash "cd $CUI_DIR && git pull origin main"
    else
        print_info "Cloning CUI repository..."
        vm_bash "mkdir -p /workspace && cd /workspace && rm -rf cui && git clone $CUI_REPO cui"
    fi

    # Verify clone succeeded
    if ! vm_bash "test -d $CUI_DIR && echo EXISTS" 2>/dev/null | grep -q "EXISTS"; then
        print_error "Failed to clone CUI repository"
        exit 1
    fi

    # Install dependencies
    print_info "Installing dependencies..."
    vm_bash "$VM_PATH_PREFIX cd $CUI_DIR && npm install"

    # Build the project
    print_info "Building CUI..."
    vm_bash "$VM_PATH_PREFIX cd $CUI_DIR && npm run build"

    print_success "CUI deployed to $CUI_DIR"
}

# Start CUI server in sandbox (API only mode)
cmd_cui_server() {
    check_lima

    local status=$(vm_status)
    if [ "$status" != "Running" ]; then
        print_error "VM is not running. Run 'cowork start' first."
        exit 1
    fi

    # Check if CUI is deployed
    if ! vm_bash "test -d $CUI_DIR && echo EXISTS" 2>/dev/null | grep -q "EXISTS"; then
        print_error "CUI not deployed. Run 'cowork cui-deploy' first."
        exit 1
    fi

    local action="${1:-start}"

    case "$action" in
        start)
            print_info "Starting CUI server on port $CUI_SERVER_PORT..."

            # Build environment variables for API
            local env_vars=""
            if [ -n "$ANTHROPIC_API_KEY" ]; then
                env_vars="ANTHROPIC_API_KEY='$ANTHROPIC_API_KEY' "
            fi
            if [ -n "$ANTHROPIC_AUTH_TOKEN" ]; then
                env_vars="${env_vars}ANTHROPIC_AUTH_TOKEN='$ANTHROPIC_AUTH_TOKEN' "
            fi
            if [ -n "$ANTHROPIC_BASE_URL" ]; then
                env_vars="${env_vars}ANTHROPIC_BASE_URL='$ANTHROPIC_BASE_URL' "
            fi

            # Stop any existing server
            vm_bash "pkill -f 'tsx.*server' 2>/dev/null || true"
            sleep 1

            # Start server in background - run limactl in background to avoid blocking
            (
                limactl shell "$VM_NAME" -- bash -c "cd $CUI_DIR && export PATH=\"\$HOME/.npm-global/bin:\$HOME/.local/bin:\$PATH\" && ${env_vars}PORT=$CUI_SERVER_PORT API_ONLY=true nohup npm run dev:api > /tmp/cui-server.log 2>&1 &" 2>/dev/null
            ) &
            sleep 4

            # Check if server started (200 or 401 both mean server is running)
            local http_code
            http_code=$(vm_bash "curl -s -o /dev/null -w '%{http_code}' http://localhost:$CUI_SERVER_PORT/api/health" 2>/dev/null)
            if [ "$http_code" == "200" ] || [ "$http_code" == "401" ]; then
                print_success "CUI server started on port $CUI_SERVER_PORT"

                # Extract and display access token from logs
                local token_line
                token_line=$(vm_bash "grep -o 'token=[a-f0-9]*' /tmp/cui-server.log 2>/dev/null | tail -1")
                if [ -n "$token_line" ]; then
                    local token="${token_line#token=}"
                    echo ""
                    echo -e "  ${GREEN}Access URL:${NC} http://localhost:$CUI_WEB_PORT#token=$token"
                    echo ""
                fi

                print_info "Logs: cowork exec 'tail -f /tmp/cui-server.log'"
            else
                print_info "Server starting... Check logs with: cowork exec 'tail -f /tmp/cui-server.log'"
            fi
            ;;
        stop)
            print_info "Stopping CUI server..."
            vm_bash "pkill -f 'node.*cui.*server' 2>/dev/null || pkill -f 'tsx.*server' 2>/dev/null || true"
            print_success "CUI server stopped"
            ;;
        restart)
            cmd_cui_server stop
            sleep 1
            cmd_cui_server start
            ;;
        status)
            local http_code
            http_code=$(vm_bash "curl -s -o /dev/null -w '%{http_code}' http://localhost:$CUI_SERVER_PORT/api/health" 2>/dev/null)
            if [ "$http_code" == "200" ] || [ "$http_code" == "401" ]; then
                print_success "CUI server is running on port $CUI_SERVER_PORT"

                # Show access token
                local token_line
                token_line=$(vm_bash "grep -o 'token=[a-f0-9]*' /tmp/cui-server.log 2>/dev/null | tail -1")
                if [ -n "$token_line" ]; then
                    local token="${token_line#token=}"
                    echo -e "  ${GREEN}Access URL:${NC} http://localhost:$CUI_WEB_PORT#token=$token"
                fi
            else
                print_error "CUI server is not running"
            fi
            ;;
        logs)
            vm_bash "tail -100 /tmp/cui-server.log 2>/dev/null || echo 'No logs found'"
            ;;
        *)
            print_error "Unknown action: $action"
            echo "Usage: cowork cui-server [start|stop|restart|status|logs]"
            exit 1
            ;;
    esac
}

# Start CUI web UI on host (connects to sandbox server)
cmd_cui_web() {
    local action="${1:-start}"

    # CUI source on host - use the workspace mount point
    # VM /workspace/cui  <->  Host ~/Downloads/cowork-workspace/cui
    local local_cui_dir="${COWORK_CUI_LOCAL:-$HOME/Downloads/cowork-workspace/cui}"

    case "$action" in
        start)
            if [ ! -d "$local_cui_dir" ]; then
                print_error "CUI source not found at: $local_cui_dir"
                print_info "Deploy CUI first with: cowork cui-deploy"
                print_info "Or set COWORK_CUI_LOCAL to your CUI source directory"
                exit 1
            fi

            print_info "Starting CUI Web UI on port $CUI_WEB_PORT..."
            print_info "Source: $local_cui_dir"
            print_info "Connecting to sandbox server at localhost:$CUI_SERVER_PORT"

            cd "$local_cui_dir"

            # Check if dependencies are installed
            if [ ! -d "node_modules" ]; then
                print_info "Installing dependencies..."
                npm install
            fi

            # Start Vite dev server
            print_info "Starting Vite dev server..."
            npm run dev:web &
            local web_pid=$!

            sleep 3

            if kill -0 $web_pid 2>/dev/null; then
                print_success "CUI Web UI started on http://localhost:$CUI_WEB_PORT"
                print_info "Press Ctrl+C to stop"
                wait $web_pid
            else
                print_error "Failed to start CUI Web UI"
            fi
            ;;
        stop)
            print_info "Stopping CUI Web UI..."
            pkill -f "vite.*cui" 2>/dev/null || pkill -f "npm.*dev:web" 2>/dev/null || true
            print_success "CUI Web UI stopped"
            ;;
        *)
            print_error "Unknown action: $action"
            echo "Usage: cowork cui-web [start|stop]"
            exit 1
            ;;
    esac
}

# Check health of CUI services
cmd_cui_health() {
    check_lima

    local status=$(vm_status)
    local all_healthy=true

    echo ""
    print_header
    echo ""
    echo "CUI Services Health Check"
    echo "========================="
    echo ""

    # Check VM status
    echo -n "VM Status: "
    if [ "$status" == "Running" ]; then
        echo -e "${GREEN}Running${NC}"
    else
        echo -e "${RED}$status${NC}"
        all_healthy=false
    fi

    # Check CUI deployment
    echo -n "CUI Deployed: "
    if [ "$status" == "Running" ] && vm_bash "test -d $CUI_DIR && echo EXISTS" 2>/dev/null | grep -q "EXISTS"; then
        echo -e "${GREEN}Yes${NC}"
    else
        echo -e "${RED}No${NC}"
        all_healthy=false
    fi

    # Check CUI server
    echo -n "CUI Server (sandbox:$CUI_SERVER_PORT): "
    if [ "$status" == "Running" ]; then
        local health_response
        health_response=$(vm_bash "curl -s -o /dev/null -w '%{http_code}' http://localhost:$CUI_SERVER_PORT/api/health" 2>/dev/null)
        if [ "$health_response" == "200" ] || [ "$health_response" == "401" ]; then
            # 200 = healthy, 401 = server running but needs auth
            echo -e "${GREEN}Running${NC}"
        else
            echo -e "${RED}Not Running${NC}"
            all_healthy=false
        fi
    else
        echo -e "${RED}VM not running${NC}"
        all_healthy=false
    fi

    # Check CUI Web (on host)
    echo -n "CUI Web UI (host:$CUI_WEB_PORT): "
    if curl -s "http://localhost:$CUI_WEB_PORT" >/dev/null 2>&1; then
        echo -e "${GREEN}Running${NC}"
    else
        echo -e "${YELLOW}Not Running${NC}"
    fi

    # Check if API proxy is working (Vite proxies /api/* to sandbox)
    echo -n "API Proxy (host -> sandbox): "
    local proxy_code
    proxy_code=$(curl -s -o /dev/null -w '%{http_code}' "http://localhost:$CUI_WEB_PORT/api/health" 2>/dev/null)
    if [ "$proxy_code" == "200" ] || [ "$proxy_code" == "401" ]; then
        echo -e "${GREEN}Working${NC}"
    else
        local direct_code
        direct_code=$(curl -s -o /dev/null -w '%{http_code}' "http://localhost:$CUI_SERVER_PORT/api/health" 2>/dev/null)
        if [ "$direct_code" == "200" ] || [ "$direct_code" == "401" ]; then
            echo -e "${YELLOW}Direct access only (proxy not configured)${NC}"
        else
            echo -e "${RED}Not Available${NC}"
        fi
    fi

    echo ""

    if [ "$all_healthy" = true ]; then
        print_success "All core services healthy"
    else
        print_error "Some services need attention"
    fi
    echo ""
}

# Full CUI setup (deploy + start server)
cmd_cui_setup() {
    print_header
    echo ""
    print_info "Setting up CUI (Claude UI)..."
    echo ""

    # Deploy CUI
    cmd_cui_deploy

    echo ""

    # Start server
    cmd_cui_server start

    echo ""
    print_success "CUI setup complete!"
    echo ""
    echo "Next steps:"
    echo "  1. Start Web UI on your host machine:"
    echo "     cowork cui-web start"
    echo ""
    echo "  2. Open http://localhost:$CUI_WEB_PORT in your browser"
    echo ""
    echo "  3. Check health anytime:"
    echo "     cowork cui-health"
    echo ""
}

# Show help
cmd_help() {
    print_header
    echo ""
    echo "Usage: cowork [options] <command> [arguments]"
    echo ""
    echo "Global Options:"
    echo "  --vm-name <name>      VM name (default: sandbox, or \$COWORK_VM_NAME)"
    echo "  --proxy <host:port>   Proxy for VM network (only for init)"
    echo "  --mount <host:vm>     Custom mount directory (only for init)"
    echo ""
    echo "Commands:"
    echo "  init      Create and start a sandbox VM"
    echo "  list      List all VMs"
    echo "  start     Start VM"
    echo "  stop      Stop VM"
    echo "  status    Show VM status"
    echo "  config    View/modify VM configuration"
    echo "  export    Export VM as pre-built image"
    echo "  delete    Delete VM"
    echo ""
    echo "  shell     Enter VM shell"
    echo "  exec      Run command in VM"
    echo "  claude    Interactive Claude session"
    echo "  ask       Non-interactive Claude query"
    echo ""
    echo "CUI (Claude UI) Commands:"
    echo "  cui-setup     Full CUI setup (deploy + start server)"
    echo "  cui-deploy    Deploy CUI to sandbox /workspace"
    echo "  cui-server    Manage CUI server in sandbox"
    echo "                  start   - Start API server (port $CUI_SERVER_PORT)"
    echo "                  stop    - Stop API server"
    echo "                  restart - Restart API server"
    echo "                  status  - Check server status"
    echo "                  logs    - View server logs"
    echo "  cui-web       Manage CUI Web UI on host"
    echo "                  start   - Start Vite dev server (port $CUI_WEB_PORT)"
    echo "                  stop    - Stop Vite dev server"
    echo "  cui-health    Check health of all CUI services"
    echo ""
    echo "Claude/Ask Options:"
    echo "  --workingdir <path>                Work in host path (e.g., ~/Projects/app)"
    echo "  --project <name>                   Work in /workspace/<name>"
    echo "  --no-dangerously-skip-permissions  Don't auto-add --dangerously-skip-permissions"
    echo "  (All Claude Code CLI options are passed through directly)"
    echo ""
    echo "Config Options:"
    echo "  --mount <host:vm>       Add mount directory"
    echo "  --remove-mount <vm>     Remove mount by VM path"
    echo "  --proxy <host:port>     Set proxy"
    echo "  --no-proxy              Remove proxy"
    echo ""
    echo "Export Options:"
    echo "  -o, --output <file>     Output file path (default: ~/Downloads/cowork-sandbox-<timestamp>.tar.gz)"
    echo ""
    echo "Examples:"
    echo "  cowork init"
    echo "  cowork claude                                  # Interactive mode"
    echo "  cowork claude --permission-mode plan           # Plan mode"
    echo "  cowork ask \"write hello world\""
    echo "  cowork ask --workingdir ~/Projects/app \"add tests\""
    echo "  cowork ask --project myapp \"create flask app\""
    echo "  cowork ask --plan \"design a REST API\""
    echo "  cowork config --mount ~/project:/project"
    echo "  cowork export -o ~/my-sandbox.tar.gz           # Export VM image"
    echo "  cowork --vm-name dev init"
    echo ""
    echo "CUI Examples:"
    echo "  cowork cui-setup                               # Full setup"
    echo "  cowork cui-server start                        # Start API server"
    echo "  cowork cui-web start                           # Start Web UI"
    echo "  cowork cui-health                              # Check health"
    echo ""
    echo "Environment Variables:"
    echo "  COWORK_VM_NAME        VM name (default: sandbox)"
    echo "  COWORK_WORKSPACE      Default workspace path (default: /workspace)"
    echo "  COWORK_PROXY_HOST     Proxy host"
    echo "  COWORK_PROXY_PORT     Proxy port (default: 7890)"
    echo "  COWORK_MOUNT          Custom mount (format: host:vm)"
    echo "  COWORK_CUI_REPO       CUI git repository URL"
    echo "  COWORK_CUI_PORT       CUI server port (default: 3001)"
    echo "  COWORK_CUI_WEB_PORT   CUI web UI port (default: 3000)"
    echo "  COWORK_CUI_LOCAL      Host path to CUI source (default: ~/Downloads/cowork-workspace/cui)"
    echo "  ANTHROPIC_API_KEY     Claude API key"
    echo "  ANTHROPIC_AUTH_TOKEN  Claude API token"
    echo "  ANTHROPIC_BASE_URL    Claude API endpoint"
    echo ""
}

# Main command dispatcher
# Parse global options first
while [ $# -gt 0 ]; do
    case "$1" in
        --proxy)
            shift
            # Parse host:port format
            if [[ "$1" == *:* ]]; then
                PROXY_HOST="${1%%:*}"
                PROXY_PORT="${1##*:}"
            else
                PROXY_HOST="$1"
            fi
            shift
            ;;
        --mount)
            shift
            CUSTOM_MOUNT="$1"
            shift
            ;;
        --vm-name)
            shift
            VM_NAME="$1"
            shift
            ;;
        *)
            break
            ;;
    esac
done

case "${1:-help}" in
    init)
        cmd_init
        ;;
    list|ls)
        cmd_list
        ;;
    start)
        cmd_start
        ;;
    stop)
        cmd_stop
        ;;
    status)
        cmd_status
        ;;
    config)
        shift
        cmd_config "$@"
        ;;
    export)
        shift
        cmd_export "$@"
        ;;
    shell)
        shift
        cmd_shell "$@"
        ;;
    claude)
        shift
        cmd_claude "$@"
        ;;
    ask)
        shift
        cmd_ask "$@"
        ;;
    exec)
        shift
        cmd_exec "$@"
        ;;
    proxy)
        shift
        cmd_proxy "$@"
        ;;
    delete)
        cmd_delete
        ;;
    cui-setup)
        cmd_cui_setup
        ;;
    cui-deploy)
        cmd_cui_deploy
        ;;
    cui-server)
        shift
        cmd_cui_server "$@"
        ;;
    cui-web)
        shift
        cmd_cui_web "$@"
        ;;
    cui-health)
        cmd_cui_health
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        print_error "Unknown command: $1"
        cmd_help
        exit 1
        ;;
esac
